### Set current working directory.
import os
#print(os.getcwd()) # this command will show your current directory. Ensure this is consistent across all files.
path = 'C:\\Users\\Reemon Spector\\Documents\\TuringTDA'
os.chdir(path)

### Import necessary libraries, notably GUDHI and py-pde.
#import time
#t0 = time.time()
import gudhi
import pde
import numpy as np

### Build the grid on which the PDE (CIMA or Schnakenberg) will be solved.
def gridForPDE(Lx, Ly, stepsize=0.5):
    # Lx = width of domain.
    # Ly = height of domain.
    # stepsize = spatial discretisation stepsize, 0.5 by default.
    ### Return a 2D grid whose boundaries are not periodic.
    return pde.CartesianGrid([[0,Lx],[0,Ly]], [int(Lx/stepsize),int(Ly/stepsize)], periodic=[False, False])

### Define the class for the CIMA system's PDE.
class CIMA(pde.PDEBase):
    ### Initialise the class with some parameters, the grid, the boundary conditions, and the RNG seed.
    def __init__(self, alpha, beta, sigma, delta, grid, bc="derivative", seed=1979):
        super().__init__()
        self.alpha = alpha          # malonic acid concentration.
        self.beta = beta            # reaction rate in chlorite PDE.
        self.sigma = sigma          # starch concentration.
        self.delta = delta          # diffusivity of chlorite relative to iodide.
        self.grid = grid            # grid generated by gridForPDE.
        self.bc = bc                # boundary condition, Neumann by default.
        self.seed = seed            # seed for random number generation of IC, 1979 (for Schnakenberg's paper) by default.
    
    ### Define the initial conditions as a (Gaussian) perturbation of the steady state.
    def ic(self,seed=1979):
        u0 = self.alpha / 5 + 0.1*pde.ScalarField.random_normal(self.grid, label="$u$", rng=np.random.default_rng(seed))
        v0 = 1 + self.alpha**2 / 25 + 0.1*pde.ScalarField.random_normal(self.grid, label="$v$", rng=np.random.default_rng(seed+1))
        return pde.FieldCollection([u0, v0])
    
    ### Define the RHS of the PDE
    def evolution_rate(self, state, t=0):   # optionally at time t, which by default is 0 since the PDE is autonomous.
        u,v = state                         # current values of u and v.
        du_dt = u.laplace(self.bc) + self.alpha - u - (4*u*v)/(1+u**2)
        dv_dt = self.sigma * ( self.delta * v.laplace(self.bc) + self.beta * u - (self.beta*u*v)/(1+u**2) )
        return pde.FieldCollection([du_dt, dv_dt])

### Define the parameters for the grid, and call the grid.
Lx = 20
Ly = 20
stepsize = 0.5
gr = gridForPDE(Lx, Ly, stepsize)

### Define some useful variables for later.
N = np.shape(gr.cell_coords)[0] * np.shape(gr.cell_coords)[1]
n = max(np.shape(gr.cell_coords)[0], np.shape(gr.cell_coords)[1])

### Construct the adjacency matrix for the gridpoints.
def nbrsForTDA(gr,stepsize):
    N = np.shape(gr.cell_coords)[0] * np.shape(gr.cell_coords)[1]   # total number of cells.
    nbrs = np.zeros([N,N])                                          # initialise empty adjacency matrix.
    cells = np.reshape(gr.cell_coords,[N,2])                        # flatten the cell coordinates into an N-by-2 matrix.
    for i in range(N):
        for j in range(N):
            if i == j:
                nbrs[i,j] = 0
            elif np.linalg.norm(cells[i]-cells[j])<1.5*stepsize:
                nbrs[i,j] = 1
    
    return nbrs

nbrs = nbrsForTDA(gr, stepsize)

### Define a 'clean-up' function to fix any buggy behaviour, and to convert infinite barcodes to ones that die at filtration value 20.
def infTo20(b,filtration_length):
    if b[1][1] > filtration_length: #i.e. if it's infinite/buggy
        return [b[1][0],float(filtration_length)]
    else:
        return [b[1][0],b[1][1]]

### Initialise a class that will compute barcodes for the CIMA system.
class CIMATDA():
    ### Initialise the class with the PDE solution, the adjacency matrix and the filtration length (which is 20 by default).
    def __init__(self, sol, nbrs, filtration_length=20):
        super().__init__()
        self.sol = sol
        self.nbrs = nbrs
        self.filtration_length = filtration_length
    
    ### Define the method that will compute the barcodes.
    def computeBarcodes(self):
        ### Start by constructing the lower-star filtration (below) and the upper-star filtration (above).
        u, v = np.reshape(self.sol.data[0],np.size(self.sol.data[0])), np.reshape(self.sol.data[1],np.size(self.sol.data[1]))   # reshape u and v appropriately.
        umin, umax, vmin, vmax = np.min(u), np.max(u), np.min(v), np.max(v)                                                     # store the min and max of u and v for later.
        ### To construct the filtration, keep track of which 0-simplices are above/below the heights dictated by the filtration value.
        below_u = np.zeros([N,self.filtration_length])                                                                          # initialise the simplices below a given height.
        above_v = np.zeros([N,self.filtration_length])                                                                          # initialise the simplices above a given height.
        for index in range(self.filtration_length):
            h_u = umin + (index-1)*(umax-umin)/(self.filtration_length-1)                                                       # the height for u at filtration value 'index'.
            h_v = vmax - (index-1)*(vmax-vmin)/(self.filtration_length-1)                                                       # the height for v at filtration value 'index'.
            for i in range(N):
                if u[i] <= h_u:
                    below_u[i,index] = 1
                if v[i] >= h_v:
                    above_v[i,index] = 1
        
        ### Initialise empty filtrations for u and v,
        stream_u = gudhi.SimplexTree()
        stream_v = gudhi.SimplexTree()
        ### and empty vertices, edges, faces; and lists of filtration values at these v, e and f.
        V_u, fV_u, E_u, fE_u, F_u, fF_u = [], [], [], [], [], []
        V_v, fV_v, E_v, fE_v, F_v, fF_v = [], [], [], [], [], []
        for i in range(N):
            ### Add all the 0-simplices at the smallest height they occur,
            ucol_i = self.filtration_length + 1 - sum(below_u[i,:])
            V_u.append([i])
            fV_u.append(ucol_i)
            vcol_i = self.filtration_length + 1 - sum(above_v[i,:])
            V_v.append([i])
            fV_v.append(vcol_i)
            ### then check for 1-simplices,
            for j in range(max(0,i-n),min(i+n+1,N)):
                ### by first ensuring i and j are neighbouring in the grid,
                if nbrs[i,j]:
                    ### and that edges are included at the maximal filtration value of their endpoints.
                    ucol_j = self.filtration_length + 1 - sum(below_u[j,:])
                    E_u.append([i,j])
                    fE_u.append(max(ucol_i,ucol_j))
                    vcol_j = self.filtration_length + 1 - sum(above_v[j,:])
                    E_v.append([i,j])
                    fE_v.append(max(vcol_i,vcol_j))
                ### Ditto check for 2-simplices,
                for k in range(max(0,j-n,i-n),min(i+n+1,j+n+1,N)):
                    ### by ensuring all three are neighbouring,
                    if nbrs[i,j] and nbrs[j,k] and nbrs[k,i]:
                        ### and ditto including a face at the maximal filtration value of its vertices.
                        ucol_k = self.filtration_length + 1 - sum(below_u[k,:])
                        F_u.append([i,j,k])
                        fF_u.append(max(ucol_i,ucol_j,ucol_k))
                        vcol_k = self.filtration_length + 1 - sum(above_v[k,:])
                        F_v.append([i,j,k])
                        fF_v.append(max(vcol_i,vcol_j,vcol_k))
        
        ### Turn all arrays into numpy arrays for efficiency,
        V_u, fV_u, E_u, fE_u, F_u, fF_u = np.asarray(V_u), np.asarray(fV_u), np.asarray(E_u), np.asarray(fE_u), np.asarray(F_u), np.asarray(fF_u)
        V_v, fV_v, E_v, fE_v, F_v, fF_v = np.asarray(V_v), np.asarray(fV_v), np.asarray(E_v), np.asarray(fE_v), np.asarray(F_v), np.asarray(fF_v)
        ### and transpose the arrays for compatibility with the 'insert_batch' function.
        stream_u.insert_batch(np.transpose(V_u), fV_u)
        stream_u.insert_batch(np.transpose(E_u), fE_u)
        stream_u.insert_batch(np.transpose(F_u), fF_u)
        stream_v.insert_batch(np.transpose(V_v), fV_v)
        stream_v.insert_batch(np.transpose(E_v), fE_v)
        stream_v.insert_batch(np.transpose(F_v), fF_v)
        ### Compute the barcodes, and return as lists.
        barcodes_u = stream_u.persistence()
        barcodes_v = stream_v.persistence()
        u0 = [infTo20(barcodes_u[i],self.filtration_length) for i in range(len(barcodes_u)) if barcodes_u[i][0]==0]
        u1 = [infTo20(barcodes_u[i],self.filtration_length) for i in range(len(barcodes_u)) if barcodes_u[i][0]==1]
        v0 = [infTo20(barcodes_v[i],self.filtration_length) for i in range(len(barcodes_v)) if barcodes_v[i][0]==0]
        v1 = [infTo20(barcodes_v[i],self.filtration_length) for i in range(len(barcodes_v)) if barcodes_v[i][0]==1]
        return np.asarray([u0,u1,v0,v1],list)

### Generate the sample "spotty" and "stripy" figures
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
for i in [0,1]:
    ### Fix the parameters
    a = [10.0,20.0][i]
    b = [0.29,1.35][i]
    s = [12.5,11.0][i]

    ### Define & solve the PDE, then compute the barcodes.
    eq = CIMA(a, b, s, 1.5, gr)
    sol = eq.solve(state=eq.ic(), t_range=250, dt=0.001, adaptive=True, tracker = ["progress","steady_state"])
    bars = CIMATDA(sol,nbrs).computeBarcodes()

    ### Plot the persistence diagrams.
    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2,2)
    fig.set_size_inches(7,6)
    sol[0].plot(title='Final $u$',cmap='turbo', ax=ax1)
    sol[1].plot(title='Final $v$',cmap='turbo', ax=ax2)
    red_patch = mpatches.Patch(color='r', label='Dimension 0')
    blue_patch = mpatches.Patch(color='b', label='Dimension 1')
    for j in range(4):
        for birth,death in bars[j]:
            ax = [ax3, ax3, ax4, ax4][j]
            title = ["$u$ persistence","$u$ persistence","$v$ persistence","$v$ persistence"][j]
            col = ['r','b','r','b'][j]
            ### Optionally, add xticks with "inf" as the final one
            # xticks = [2*i for i in range(11)]
            # #xticks.append(21)
            # labs = [str(2*i) for i in range(11)]
            # #labs.append("inf")
            # ax.set_xticks(xticks,labs)
            ax.set_title(title)
            ax.set_xlabel("Birth")
            ax.set_ylabel("Death")
            ax.set_xlim(0,21)
            ax.set_ylim(0,21)
            ax.plot([0,21],[0,21],linestyle='-',linewidth=0.4,c='black')
            ax.plot(birth,death,color=col,marker='o',markersize=5,alpha=0.4)   
        
        ax.legend(handles=[red_patch, blue_patch])
    
    plt.tight_layout()
    plt.savefig(["stripy.png","spotty.png"][i], dpi=300)

plt.show()
